import { BadRequestException, Injectable, Logger, Optional } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, In, LessThan, MoreThan, Repository } from 'typeorm';

import {
  CalendarEventEntity,
  EventStatus,
  EventRescheduleRequestEntity,
  RescheduleRequestStatus,
  UserEntity,
} from 'src/database/entities';
import { EventParticipantEntity } from 'src/database/entities/event-participant.entity';
import {
  AvailabilityType,
  UserAvailabilityEntity,
} from 'src/database/entities/user-availability.entity';
import { CreateAvailabilityDto, CreateRecurringAvailabilityDto } from './dto/availability.dto';
import { AutoScheduleService } from './auto-schedule.service';
import { buildUtcDateFromLocalTime } from './calendar.utils';

const ACTIVE_EVENT_STATUSES = [
  EventStatus.SCHEDULED,
  EventStatus.PENDING_CONFIRMATION,
  EventStatus.IN_PROGRESS,
  EventStatus.RESCHEDULING,
];

const BLOCKING_TYPES = [
  AvailabilityType.BUSY,
  AvailabilityType.OUT_OF_OFFICE,
  AvailabilityType.DO_NOT_DISTURB,
];

export interface SetAvailabilityInput {
  userId: string;
  slots?: CreateAvailabilityDto[];
  recurring?: CreateRecurringAvailabilityDto;
  allowConflicts?: boolean;
  timeZone?: string;
}

export interface SetAvailabilityResult {
  entries: UserAvailabilityEntity[];
  conflictingEvents: CalendarEventEntity[];
  rescheduleRequests: Array<{ eventId: string; requestId: string; status: string }>;
}

@Injectable()
export class AvailabilityService {
  private readonly logger = new Logger(AvailabilityService.name);

  constructor(
    @InjectRepository(UserAvailabilityEntity)
    private readonly availabilityRepository: Repository<UserAvailabilityEntity>,
    @InjectRepository(CalendarEventEntity)
    private readonly calendarRepository: Repository<CalendarEventEntity>,
    @InjectRepository(EventParticipantEntity)
    private readonly participantRepository: Repository<EventParticipantEntity>,
    @InjectRepository(EventRescheduleRequestEntity)
    private readonly rescheduleRepository: Repository<EventRescheduleRequestEntity>,
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
    private readonly dataSource: DataSource,
    @Optional() private readonly autoScheduleService?: AutoScheduleService,
    @Optional() private readonly eventEmitter?: EventEmitter2,
  ) {}

  async setUserAvailability(input: SetAvailabilityInput): Promise<SetAvailabilityResult> {
    if (!input.slots?.length && !input.recurring) {
      throw new BadRequestException('slots or recurring availability is required');
    }

    const user = await this.userRepository.findOne({
      where: { id: input.userId },
      select: ['id', 'timeZone'],
    });
    const userTimeZone = input.timeZone || user?.timeZone || 'UTC';

    if (input.timeZone && user && user.timeZone !== input.timeZone) {
      await this.userRepository.update({ id: input.userId }, { timeZone: input.timeZone });
    }

    const createdEntries: UserAvailabilityEntity[] = [];
    const conflictRanges: Array<{ start: Date; end: Date }> = [];

    if (input.slots?.length) {
      const normalizedSlots = input.slots.map((slot) => {
        const start = this.parseDateTime(slot.startTime, userTimeZone);
        const end = this.parseDateTime(slot.endTime, userTimeZone);
        if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime()) || start >= end) {
          throw new BadRequestException('Invalid availability time slot');
        }
        if (
          slot.type === AvailabilityType.OUT_OF_OFFICE &&
          end.getTime() - start.getTime() > 24 * 60 * 60 * 1000
        ) {
          throw new BadRequestException('Out of office longer than 1 day requires admin approval');
        }
        return { ...slot, startTime: start, endTime: end };
      });

      this.assertNoOverlaps(
        normalizedSlots.map((slot) => ({ start: slot.startTime, end: slot.endTime })),
      );

      for (const slot of normalizedSlots) {
        await this.assertNoExistingOverlap(input.userId, slot.startTime, slot.endTime);
        const entry = this.availabilityRepository.create({
          userId: input.userId,
          startTime: slot.startTime,
          endTime: slot.endTime,
          type: slot.type,
          note: slot.note,
          isRecurring: false,
          isAutoGenerated: false,
        });
        createdEntries.push(entry);

        if (BLOCKING_TYPES.includes(slot.type)) {
          conflictRanges.push({ start: slot.startTime, end: slot.endTime });
        }
      }
    }

    if (input.recurring) {
      if (!input.recurring.slots?.length) {
        throw new BadRequestException('Recurring slots are required');
      }

      const recurringStart = input.recurring.startDate
        ? this.parseLocalDateOnly(input.recurring.startDate, userTimeZone)
        : null;
      const recurringEnd = input.recurring.endDate
        ? this.parseLocalDateOnly(input.recurring.endDate, userTimeZone)
        : null;
      if (
        (recurringStart && Number.isNaN(recurringStart.getTime())) ||
        (recurringEnd && Number.isNaN(recurringEnd.getTime()))
      ) {
        throw new BadRequestException('Invalid recurring date range');
      }
      if (recurringStart && recurringEnd && recurringStart >= recurringEnd) {
        throw new BadRequestException('Recurring startDate must be before endDate');
      }

      this.assertNoRecurringOverlaps(input.recurring.slots);

      const dayOfWeekValues = input.recurring.slots.map((slot) => slot.dayOfWeek);
      const existingRecurring = await this.availabilityRepository.find({
        where: {
          userId: input.userId,
          isRecurring: true,
          dayOfWeek: In(dayOfWeekValues),
        },
      });

      for (const slot of input.recurring.slots) {
        this.assertValidDayOfWeek(slot.dayOfWeek);
        const startMinutes = this.parseTimeToMinutes(slot.startTime);
        const endMinutes = this.parseTimeToMinutes(slot.endTime);
        if (startMinutes >= endMinutes) {
          throw new BadRequestException('Recurring slot startTime must be before endTime');
        }

        for (const existing of existingRecurring.filter(
          (entry) => entry.dayOfWeek === slot.dayOfWeek,
        )) {
          const existingStart = this.parseTimeToMinutes(existing.recurringStartTime || '00:00');
          const existingEnd = this.parseTimeToMinutes(existing.recurringEndTime || '00:00');
          if (this.overlaps(startMinutes, endMinutes, existingStart, existingEnd)) {
            if (
              this.dateRangesOverlap(
                input.recurring.startDate ? new Date(input.recurring.startDate) : null,
                input.recurring.endDate ? new Date(input.recurring.endDate) : null,
                existing.recurringStartDate ? new Date(existing.recurringStartDate) : null,
                existing.recurringEndDate ? new Date(existing.recurringEndDate) : null,
              )
            ) {
              throw new BadRequestException('Recurring availability overlaps existing slot');
            }
          }
        }

        const entryData = {
          userId: input.userId,
          type: input.recurring.type,
          isRecurring: true,
          dayOfWeek: slot.dayOfWeek,
          recurringStartTime: slot.startTime,
          recurringEndTime: slot.endTime,
          recurringStartDate: recurringStart ?? undefined,
          recurringEndDate: recurringEnd ?? undefined,
          note: input.recurring.note,
          isAutoGenerated: false,
        };
        const entry = this.availabilityRepository.create(entryData);
        createdEntries.push(entry);
      }

      if (BLOCKING_TYPES.includes(input.recurring.type)) {
        const { start, end } = this.resolveRecurringRange(input.recurring);
        const expanded = this.expandRecurringSlots(input.recurring.slots, start, end);
        conflictRanges.push(...expanded);
      }
    }

    const conflictingEvents = await this.findConflictingEvents(input.userId, conflictRanges, true);

    if (conflictingEvents.length > 0 && !input.allowConflicts) {
      throw new BadRequestException({
        message: 'Availability conflicts with existing events. Confirm to reschedule them.',
        conflicts: conflictingEvents.map((event) => ({
          eventId: event.id,
          title: event.title,
          startTime: event.startTime,
          endTime: event.endTime,
          status: event.status,
        })),
      });
    }

    const savedEntries = await this.availabilityRepository.save(createdEntries);
    const rescheduleRequests = await this.triggerRescheduleForConflicts(
      input.userId,
      conflictingEvents,
      Boolean(input.allowConflicts),
    );

    if (conflictingEvents.length > 0) {
      this.logger.warn(`Availability update conflicts with ${conflictingEvents.length} event(s)`);
    }

    this.eventEmitter?.emit('calendar.availabilityUpdated', {
      userId: input.userId,
      entries: savedEntries.map((entry) => entry.id),
      conflictEventIds: conflictingEvents.map((event) => event.id),
    });

    return { entries: savedEntries, conflictingEvents, rescheduleRequests };
  }

  async syncCalendarEvents(input: { start: Date; end: Date; userIds?: string[] }): Promise<{
    deleted: number;
    created: number;
    eventsSynced: number;
  }> {
    const rangeStart = new Date(input.start);
    const rangeEnd = new Date(input.end);
    if (
      Number.isNaN(rangeStart.getTime()) ||
      Number.isNaN(rangeEnd.getTime()) ||
      rangeStart >= rangeEnd
    ) {
      throw new BadRequestException('Invalid sync range');
    }

    return this.dataSource.transaction(async (manager) => {
      const availabilityRepo = manager.getRepository(UserAvailabilityEntity);
      const calendarRepo = manager.getRepository(CalendarEventEntity);
      const participantRepo = manager.getRepository(EventParticipantEntity);

      const events = await calendarRepo.find({
        where: {
          startTime: LessThan(rangeEnd),
          endTime: MoreThan(rangeStart),
          status: In(ACTIVE_EVENT_STATUSES),
        },
      });

      let filteredEvents = events;
      if (input.userIds?.length) {
        const participantEvents = await participantRepo.find({
          where: { userId: In(input.userIds) },
        });
        const participantEventIds = new Set(participantEvents.map((p) => p.eventId));
        filteredEvents = events.filter(
          (event) =>
            input.userIds!.includes(event.organizerId) || participantEventIds.has(event.id),
        );
      }

      const deleteQuery = availabilityRepo
        .createQueryBuilder()
        .delete()
        .where('isAutoGenerated = :auto', { auto: true })
        .andWhere('startTime < :rangeEnd AND endTime > :rangeStart', {
          rangeStart,
          rangeEnd,
        });

      if (input.userIds?.length) {
        deleteQuery.andWhere('userId IN (:...userIds)', { userIds: input.userIds });
      }

      const deleteResult = await deleteQuery.execute();

      if (filteredEvents.length === 0) {
        return { deleted: deleteResult.affected || 0, created: 0, eventsSynced: 0 };
      }

      const eventIds = filteredEvents.map((event) => event.id);
      const participants = await participantRepo.find({
        where: { eventId: In(eventIds) },
      });
      const participantsByEvent = new Map<string, Set<string>>();
      for (const participant of participants) {
        const set = participantsByEvent.get(participant.eventId) ?? new Set<string>();
        set.add(participant.userId);
        participantsByEvent.set(participant.eventId, set);
      }

      const entries: UserAvailabilityEntity[] = [];
      for (const event of filteredEvents) {
        const userIds = new Set<string>([event.organizerId]);
        const participantIds = participantsByEvent.get(event.id);
        if (participantIds) {
          participantIds.forEach((id) => userIds.add(id));
        }

        for (const userId of userIds) {
          if (input.userIds?.length && !input.userIds.includes(userId)) {
            continue;
          }
          entries.push(
            availabilityRepo.create({
              userId,
              startTime: event.startTime,
              endTime: event.endTime,
              type: AvailabilityType.BUSY,
              isAutoGenerated: true,
              linkedEventId: event.id,
              note: 'Synced from calendar event',
            }),
          );
        }
      }

      const saved = await availabilityRepo.save(entries);

      return {
        deleted: deleteResult.affected || 0,
        created: saved.length,
        eventsSynced: filteredEvents.length,
      };
    });
  }

  private async assertNoExistingOverlap(userId: string, start: Date, end: Date): Promise<void> {
    const overlaps = await this.availabilityRepository.find({
      where: {
        userId,
        isAutoGenerated: false,
        startTime: LessThan(end),
        endTime: MoreThan(start),
      },
    });
    if (overlaps.length > 0) {
      throw new BadRequestException('Availability overlaps existing slots');
    }
  }

  private async findConflictingEvents(
    userId: string,
    ranges: Array<{ start: Date; end: Date }>,
    onlyFuture: boolean,
  ): Promise<CalendarEventEntity[]> {
    if (ranges.length === 0) {
      return [];
    }

    const conflicts = new Map<string, CalendarEventEntity>();
    const now = new Date();

    for (const range of ranges) {
      const organizerEvents = await this.calendarRepository.find({
        where: {
          organizerId: userId,
          startTime: LessThan(range.end),
          endTime: MoreThan(range.start),
          status: In(ACTIVE_EVENT_STATUSES),
        },
      });
      organizerEvents.forEach((event) => {
        if (!onlyFuture || event.endTime > now) {
          conflicts.set(event.id, event);
        }
      });

      const participantEvents = await this.participantRepository
        .createQueryBuilder('participant')
        .innerJoinAndSelect('participant.event', 'event')
        .where('participant.userId = :userId', { userId })
        .andWhere('event.startTime < :rangeEnd AND event.endTime > :rangeStart', {
          rangeStart: range.start,
          rangeEnd: range.end,
        })
        .andWhere('event.status IN (:...statuses)', { statuses: ACTIVE_EVENT_STATUSES })
        .getMany();

      for (const participant of participantEvents) {
        if (participant.event && (!onlyFuture || participant.event.endTime > now)) {
          conflicts.set(participant.event.id, participant.event);
        }
      }
    }

    return Array.from(conflicts.values());
  }

  private async triggerRescheduleForConflicts(
    userId: string,
    events: CalendarEventEntity[],
    allowConflicts: boolean,
  ): Promise<Array<{ eventId: string; requestId: string; status: string }>> {
    if (!allowConflicts || events.length === 0 || !this.autoScheduleService) {
      return [];
    }

    const pendingRequests = await this.rescheduleRepository.find({
      where: {
        eventId: In(events.map((event) => event.id)),
        status: RescheduleRequestStatus.PENDING,
      },
    });
    const pendingEventIds = new Set(pendingRequests.map((request) => request.eventId));

    const createdRequests: EventRescheduleRequestEntity[] = [];
    for (const event of events) {
      if (pendingEventIds.has(event.id)) {
        continue;
      }
      createdRequests.push(
        this.rescheduleRepository.create({
          eventId: event.id,
          requesterId: userId,
          reason: 'Availability update conflict',
          useAutoSchedule: true,
          status: RescheduleRequestStatus.PENDING,
        }),
      );
    }

    if (createdRequests.length === 0) {
      return [];
    }

    const saved = await this.rescheduleRepository.save(createdRequests);
    const results: Array<{ eventId: string; requestId: string; status: string }> = [];

    for (const request of saved) {
      const result = await this.autoScheduleService.handleRescheduleRequest(request.id, userId);
      results.push({
        eventId: request.eventId,
        requestId: request.id,
        status: result.manualRequired ? 'MANUAL_REQUIRED' : 'RESCHEDULED',
      });
    }

    return results;
  }

  private assertNoOverlaps(ranges: Array<{ start: Date; end: Date }>) {
    const sorted = [...ranges].sort((a, b) => a.start.getTime() - b.start.getTime());
    for (let i = 1; i < sorted.length; i += 1) {
      if (sorted[i].start < sorted[i - 1].end) {
        throw new BadRequestException('Availability slots overlap');
      }
    }
  }

  private overlaps(startA: number, endA: number, startB: number, endB: number): boolean {
    return startA < endB && endA > startB;
  }

  private parseTimeToMinutes(time: string): number {
    const [hour, minute, second] = time.split(':').map((value) => Number(value));
    const safeHour = Number.isFinite(hour) ? hour : 0;
    const safeMinute = Number.isFinite(minute) ? minute : 0;
    const safeSecond = Number.isFinite(second) ? second : 0;
    return safeHour * 60 + safeMinute + Math.floor(safeSecond / 60);
  }

  private assertValidDayOfWeek(dayOfWeek: number) {
    if (!Number.isInteger(dayOfWeek) || dayOfWeek < 0 || dayOfWeek > 6) {
      throw new BadRequestException('dayOfWeek must be between 0 and 6');
    }
  }

  private dateRangesOverlap(
    startA: Date | null,
    endA: Date | null,
    startB: Date | null,
    endB: Date | null,
  ): boolean {
    const effectiveStartA = startA ?? new Date(0);
    const effectiveStartB = startB ?? new Date(0);
    const effectiveEndA = endA ?? new Date(8640000000000000);
    const effectiveEndB = endB ?? new Date(8640000000000000);
    return effectiveStartA <= effectiveEndB && effectiveStartB <= effectiveEndA;
  }

  private resolveRecurringRange(input: CreateRecurringAvailabilityDto): { start: Date; end: Date } {
    const start = input.startDate ? new Date(input.startDate) : new Date();
    const end = input.endDate ? new Date(input.endDate) : this.addDays(start, 30);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime()) || start >= end) {
      throw new BadRequestException('Invalid recurring date range');
    }
    return { start, end };
  }

  private expandRecurringSlots(
    slots: CreateRecurringAvailabilityDto['slots'],
    rangeStart: Date,
    rangeEnd: Date,
  ): Array<{ start: Date; end: Date }> {
    const ranges: Array<{ start: Date; end: Date }> = [];
    const cursor = new Date(rangeStart);
    cursor.setHours(0, 0, 0, 0);
    const end = new Date(rangeEnd);
    end.setHours(23, 59, 59, 999);

    for (let day = new Date(cursor); day <= end; day = this.addDays(day, 1)) {
      for (const slot of slots) {
        if (day.getDay() !== slot.dayOfWeek) {
          continue;
        }
        const start = this.buildDateTime(day, slot.startTime);
        const endTime = this.buildDateTime(day, slot.endTime);
        if (start < rangeEnd && endTime > rangeStart) {
          ranges.push({ start, end: endTime });
        }
      }
    }
    return ranges;
  }

  private buildDateTime(base: Date, time: string): Date {
    const [hour, minute, second] = time.split(':').map((value) => Number(value));
    const result = new Date(base);
    result.setHours(
      Number.isFinite(hour) ? hour : 0,
      Number.isFinite(minute) ? minute : 0,
      Number.isFinite(second) ? second : 0,
      0,
    );
    return result;
  }

  private addDays(date: Date, days: number): Date {
    const next = new Date(date);
    next.setDate(next.getDate() + days);
    return next;
  }

  private assertNoRecurringOverlaps(slots: CreateRecurringAvailabilityDto['slots']) {
    const grouped = new Map<number, Array<{ start: number; end: number }>>();

    for (const slot of slots) {
      this.assertValidDayOfWeek(slot.dayOfWeek);
      const startMinutes = this.parseTimeToMinutes(slot.startTime);
      const endMinutes = this.parseTimeToMinutes(slot.endTime);
      if (startMinutes >= endMinutes) {
        throw new BadRequestException('Recurring slot startTime must be before endTime');
      }
      const list = grouped.get(slot.dayOfWeek) ?? [];
      list.push({ start: startMinutes, end: endMinutes });
      grouped.set(slot.dayOfWeek, list);
    }

    for (const ranges of grouped.values()) {
      const sorted = ranges.sort((a, b) => a.start - b.start);
      for (let i = 1; i < sorted.length; i += 1) {
        if (sorted[i].start < sorted[i - 1].end) {
          throw new BadRequestException('Recurring availability slots overlap');
        }
      }
    }
  }

  private parseDateTime(value: string, timeZone: string): Date {
    if (!value) {
      return new Date(NaN);
    }
    const hasOffset = /[zZ]|[+-]\d{2}:?\d{2}$/.test(value);
    if (hasOffset) {
      return new Date(value);
    }

    const [datePart, timePartRaw] = value.split('T');
    if (!datePart || !timePartRaw) {
      return new Date(value);
    }
    const [year, month, day] = datePart.split('-').map((part) => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return new Date(value);
    }
    const timePart = timePartRaw.length === 5 ? `${timePartRaw}:00` : timePartRaw;
    const baseDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
    return buildUtcDateFromLocalTime(baseDate, timePart, timeZone);
  }

  private parseLocalDateOnly(value: string, timeZone: string): Date {
    if (!value) {
      return new Date(NaN);
    }
    const [year, month, day] = value.split('-').map((part) => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return new Date(value);
    }
    const baseDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
    return buildUtcDateFromLocalTime(baseDate, '00:00:00', timeZone);
  }
}
