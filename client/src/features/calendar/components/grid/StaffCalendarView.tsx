import { useCallback, useEffect, useMemo, useState } from "react";
import {
  format,
  startOfWeek,
  addDays,
  isSameDay,
  startOfMonth,
  endOfMonth,
  endOfWeek,
  isSameMonth,
  addMonths,
  subMonths,
} from "date-fns";
import { ChevronLeft, ChevronRight, Clock, PlusCircle } from "lucide-react";
import { toast } from "sonner";
import { getStaffAvailability, setAvailability } from "../../api";
import { AvailabilityType, type CalendarEvent } from "../../types";
import { STORAGE_KEYS } from "@/constants";
import { getStoredJson } from "@/shared/utils/storage";

type AvailabilityEntry = {
  id: string;
  startTime?: string;
  endTime?: string;
  type: AvailabilityType;
  isRecurring?: boolean;
  dayOfWeek?: number;
  recurringStartTime?: string;
  recurringEndTime?: string;
  recurringStartDate?: string;
  recurringEndDate?: string;
  isAutoGenerated?: boolean;
  note?: string;
};

type StaffAvailabilityPayload = {
  staffId: string;
  name?: string;
  availability?: AvailabilityEntry[];
  events?: CalendarEvent[];
};

type CalendarSlot = {
  id: string;
  kind: "event" | "availability";
  title: string;
  startTime: Date;
  endTime: Date;
  availabilityType?: AvailabilityType;
  note?: string;
};

export const StaffCalendarView = () => {
  const [currentDate, setCurrentDate] = useState(new Date());
  const [slots, setSlots] = useState<CalendarSlot[]>([]);
  const [loading, setLoading] = useState(false);
  const [viewMode, setViewMode] = useState<"week" | "month">("week");
  const [availabilityType, setAvailabilityType] = useState<AvailabilityType>(
    AvailabilityType.BUSY,
  );
  const [availabilityStart, setAvailabilityStart] = useState("");
  const [availabilityEnd, setAvailabilityEnd] = useState("");
  const [availabilityNote, setAvailabilityNote] = useState("");
  const [availabilityAllowConflicts, setAvailabilityAllowConflicts] =
    useState(false);
  const [availabilitySaving, setAvailabilitySaving] = useState(false);

  const currentUser = useMemo(
    () => getStoredJson<{ id?: string }>(STORAGE_KEYS.USER),
    [],
  );
  const staffId = currentUser?.id;

  const weekStartDate = useMemo(() => startOfWeek(currentDate), [currentDate]);
  const weekDays = useMemo(
    () => Array.from({ length: 7 }).map((_, i) => addDays(weekStartDate, i)),
    [weekStartDate],
  );

  const monthStartDate = useMemo(
    () => startOfWeek(startOfMonth(currentDate)),
    [currentDate],
  );
  const monthEndDate = useMemo(
    () => endOfWeek(endOfMonth(currentDate)),
    [currentDate],
  );
  const monthDays = useMemo(() => {
    const days: Date[] = [];
    for (
      let day = new Date(monthStartDate);
      day <= monthEndDate;
      day = addDays(day, 1)
    ) {
      days.push(new Date(day));
    }
    return days;
  }, [monthStartDate, monthEndDate]);

  const parseRecurringTime = (value?: string) => {
    if (!value) return null;
    const [hourRaw, minuteRaw, secondRaw] = value.split(":");
    const hours = Number(hourRaw);
    const minutes = Number(minuteRaw ?? "0");
    const seconds = Number(secondRaw ?? "0");
    if (
      Number.isNaN(hours) ||
      Number.isNaN(minutes) ||
      Number.isNaN(seconds)
    ) {
      return null;
    }
    return { hours, minutes, seconds };
  };

  const expandAvailabilityEntry = useCallback(
    (entry: AvailabilityEntry): CalendarSlot[] => {
      const visibleTypes = new Set([
        AvailabilityType.BUSY,
        AvailabilityType.OUT_OF_OFFICE,
        AvailabilityType.DO_NOT_DISTURB,
        AvailabilityType.AVAILABLE,
        AvailabilityType.PREFERRED,
      ]);
      if (!visibleTypes.has(entry.type)) return [];
      if (entry.isAutoGenerated) return [];

      if (!entry.isRecurring) {
        if (!entry.startTime || !entry.endTime) return [];
        const start = new Date(entry.startTime);
        const end = new Date(entry.endTime);
        if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) return [];
        if (end <= start) return [];
        return [
          {
            id: `availability-${entry.id}`,
            kind: "availability",
            title: entry.note?.trim()
              ? entry.note.trim()
              : entry.type.replaceAll("_", " "),
            startTime: start,
            endTime: end,
            availabilityType: entry.type,
            note: entry.note,
          },
        ];
      }

      const startTimeParts = parseRecurringTime(entry.recurringStartTime);
      const endTimeParts = parseRecurringTime(entry.recurringEndTime);
      if (!startTimeParts || !endTimeParts) return [];
      if (typeof entry.dayOfWeek !== "number") return [];

      const recurringStartDate = entry.recurringStartDate
        ? new Date(entry.recurringStartDate)
        : null;
      const recurringEndDate = entry.recurringEndDate
        ? new Date(entry.recurringEndDate)
        : null;

      return weekDays
        .filter((day) => day.getDay() === entry.dayOfWeek)
        .flatMap((day) => {
          if (recurringStartDate && day < recurringStartDate) return [];
          if (recurringEndDate && day > recurringEndDate) return [];

          const start = new Date(day);
          start.setHours(
            startTimeParts.hours,
            startTimeParts.minutes,
            startTimeParts.seconds,
            0,
          );
          const end = new Date(day);
          end.setHours(
            endTimeParts.hours,
            endTimeParts.minutes,
            endTimeParts.seconds,
            0,
          );
          if (end <= start) return [];
          return [
            {
              id: `availability-${entry.id}-${day.toISOString()}`,
              kind: "availability",
              title: entry.note?.trim()
                ? entry.note.trim()
                : entry.type.replaceAll("_", " "),
              startTime: start,
              endTime: end,
              availabilityType: entry.type,
              note: entry.note,
            },
          ];
        });
    },
    [weekDays],
  );

  const fetchSchedule = useCallback(async () => {
    if (!staffId) {
      setSlots([]);
      return;
    }

    try {
      setLoading(true);
      const rangeStart =
        viewMode === "month" ? monthStartDate : weekStartDate;
      const rangeEnd =
        viewMode === "month" ? addDays(monthEndDate, 1) : addDays(weekStartDate, 7);
      const startStr = rangeStart.toISOString();
      const endStr = rangeEnd.toISOString();
      const response = await getStaffAvailability(startStr, endStr, [staffId]);
      const payload = (response as { data?: StaffAvailabilityPayload[] }).data ?? response;
      const staffEntries = Array.isArray(payload) ? payload : [];
      const staffEntry =
        staffEntries.find((entry) => entry.staffId === staffId) ?? staffEntries[0];
      const events = staffEntry?.events ?? [];
      const availability = staffEntry?.availability ?? [];

      if (import.meta.env.DEV) {
        console.debug("[Calendar] Staff availability response", {
          staffId,
          rangeStart: startStr,
          rangeEnd: endStr,
          staffCount: staffEntries.length,
          events: events.length,
          availability: availability.length,
        });
      }

      const eventSlots: CalendarSlot[] = events.map((event) => ({
        id: `event-${event.id}`,
        kind: "event",
        title: event.title || event.type,
        startTime: new Date(event.startTime),
        endTime: new Date(event.endTime),
      }));

      const availabilitySlots = availability.flatMap(expandAvailabilityEntry);

      const mergedSlots = [...eventSlots, ...availabilitySlots];
      setSlots(mergedSlots);
      if (import.meta.env.DEV) {
        console.debug("[Calendar] Render slots", {
          total: mergedSlots.length,
          events: eventSlots.length,
          availability: availabilitySlots.length,
        });
      }
    } catch (error) {
      console.error("Failed to load staff availability:", error);
      toast.error("Could not load calendar availability");
      setSlots([]);
    } finally {
      setLoading(false);
    }
  }, [staffId, viewMode, weekStartDate, monthStartDate, monthEndDate, expandAvailabilityEntry]);

  useEffect(() => {
    fetchSchedule();
  }, [fetchSchedule]);

  const hours = Array.from({ length: 11 }).map(
    (_, i) => i + 8, // 8 AM to 6 PM
  );

  const getSlotsForCell = (day: Date, hour: number) => {
    const cellStart = new Date(day);
    cellStart.setHours(hour, 0, 0, 0);
    const cellEnd = new Date(day);
    cellEnd.setHours(hour + 1, 0, 0, 0);

    return slots.filter(
      (slot) => slot.startTime < cellEnd && slot.endTime > cellStart,
    );
  };

  const getSlotStyles = (slot: CalendarSlot) => {
    if (slot.kind === "event") {
      return "bg-indigo-50 border border-indigo-100 text-indigo-700 hover:bg-indigo-100";
    }
    switch (slot.availabilityType) {
      case AvailabilityType.PREFERRED:
        return "bg-teal-50 border border-teal-200 text-teal-700 hover:bg-teal-100";
      case AvailabilityType.AVAILABLE:
        return "bg-emerald-50 border border-emerald-200 text-emerald-700 hover:bg-emerald-100";
      case AvailabilityType.OUT_OF_OFFICE:
        return "bg-amber-50 border border-amber-200 text-amber-700 hover:bg-amber-100";
      case AvailabilityType.DO_NOT_DISTURB:
        return "bg-rose-50 border border-rose-200 text-rose-700 hover:bg-rose-100";
      default:
        return "bg-slate-100 border border-slate-200 text-slate-700 hover:bg-slate-200";
    }
  };

  const getSlotBadge = (slot: CalendarSlot) => {
    if (slot.kind === "event") {
      return { label: "Event", className: "bg-indigo-100 text-indigo-700" };
    }
    switch (slot.availabilityType) {
      case AvailabilityType.PREFERRED:
        return { label: "Preferred", className: "bg-teal-100 text-teal-700" };
      case AvailabilityType.AVAILABLE:
        return { label: "Available", className: "bg-emerald-100 text-emerald-700" };
      case AvailabilityType.OUT_OF_OFFICE:
        return { label: "Out of office", className: "bg-amber-100 text-amber-700" };
      case AvailabilityType.DO_NOT_DISTURB:
        return { label: "Do not disturb", className: "bg-rose-100 text-rose-700" };
      default:
        return { label: "Busy", className: "bg-slate-200 text-slate-700" };
    }
  };

  const formatSlotTime = (slot: CalendarSlot) =>
    `${format(slot.startTime, "h:mm a")} - ${format(slot.endTime, "h:mm a")}`;

  const getDayIndicators = (day: Date) => {
    const start = new Date(day);
    start.setHours(0, 0, 0, 0);
    const end = new Date(day);
    end.setHours(23, 59, 59, 999);

    const indicators = new Set<string>();
    slots.forEach((slot) => {
      if (slot.startTime < end && slot.endTime > start) {
        if (slot.kind === "event") {
          indicators.add("event");
        } else {
          indicators.add(slot.availabilityType || "busy");
        }
      }
    });
    return Array.from(indicators);
  };

  const handleAddAvailability = async () => {
    if (!availabilityStart || !availabilityEnd) {
      toast.error("Please select both start and end times.");
      return;
    }

    const start = new Date(availabilityStart);
    const end = new Date(availabilityEnd);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
      toast.error("Invalid date/time.");
      return;
    }
    if (start >= end) {
      toast.error("End time must be after start time.");
      return;
    }
    const durationMs = end.getTime() - start.getTime();
    if (
      availabilityType === AvailabilityType.OUT_OF_OFFICE &&
      durationMs > 24 * 60 * 60 * 1000
    ) {
      toast.error("Leave longer than 1 day requires admin approval.");
      return;
    }

    try {
      setAvailabilitySaving(true);
      await setAvailability({
        slots: [
          {
            startTime: start.toISOString(),
            endTime: end.toISOString(),
            type: availabilityType,
            note: availabilityNote.trim() ? availabilityNote.trim() : undefined,
          },
        ],
        allowConflicts: availabilityAllowConflicts,
        timeZone:
          typeof Intl !== "undefined"
            ? Intl.DateTimeFormat().resolvedOptions().timeZone
            : undefined,
      });
      toast.success("Availability saved.");
      setAvailabilityStart("");
      setAvailabilityEnd("");
      setAvailabilityNote("");
      await fetchSchedule();
    } catch (error) {
      const responseData = (error as any)?.response?.data;
      const payloadMessage = responseData?.message;
      const message =
        typeof payloadMessage === "string"
          ? payloadMessage
          : typeof responseData?.error === "string"
            ? responseData.error
            : error instanceof Error
              ? error.message
              : "Failed to save availability.";
      const conflicts =
        responseData?.conflicts ||
        (typeof payloadMessage === "object" ? payloadMessage?.conflicts : null);
      if (conflicts?.length) {
        const firstConflict = conflicts[0];
        toast.error(
          `${message} Conflict: ${firstConflict.title || "Event"} (${format(
            new Date(firstConflict.startTime),
            "MMM d, h:mm a",
          )})`,
        );
      } else {
        toast.error(message);
      }
      console.error("Failed to save availability:", error);
    } finally {
      setAvailabilitySaving(false);
    }
  };

  return (
    <div className="space-y-4">
      <div className="bg-white rounded-xl border border-gray-200 shadow-sm p-4">
        <div className="flex flex-wrap items-center justify-between gap-3">
          <div>
            <h3 className="text-sm font-semibold text-slate-900">
              Mark availability / blocks
            </h3>
            <p className="text-xs text-gray-500 mt-1">
              Set preferred/available time for auto-scheduling or block time from hearings.
            </p>
          </div>
          <button
            onClick={handleAddAvailability}
            disabled={availabilitySaving}
            className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-slate-900 text-white text-sm hover:bg-slate-800 disabled:opacity-50"
          >
            <PlusCircle className="w-4 h-4" />
            {availabilitySaving ? "Saving..." : "Add availability"}
          </button>
        </div>

        <div className="mt-4 grid gap-3 md:grid-cols-4">
          <div>
            <label className="text-xs text-gray-500">Type</label>
            <select
              value={availabilityType}
              onChange={(event) =>
                setAvailabilityType(event.target.value as AvailabilityType)
              }
              className="mt-1 w-full text-sm border border-gray-200 rounded-lg px-3 py-2 focus:ring-teal-500 focus:border-teal-500"
            >
              <option value={AvailabilityType.AVAILABLE}>
                Available (auto-assign)
              </option>
              <option value={AvailabilityType.PREFERRED}>
                Preferred (auto-assign)
              </option>
              <option value={AvailabilityType.BUSY}>Busy</option>
              <option value={AvailabilityType.OUT_OF_OFFICE}>Out of office</option>
              <option value={AvailabilityType.DO_NOT_DISTURB}>Do not disturb</option>
            </select>
          </div>
          <div>
            <label className="text-xs text-gray-500">Start</label>
            <input
              type="datetime-local"
              value={availabilityStart}
              onChange={(event) => setAvailabilityStart(event.target.value)}
              max={availabilityEnd || undefined}
              className="mt-1 w-full text-sm border border-gray-200 rounded-lg px-3 py-2 focus:ring-teal-500 focus:border-teal-500"
            />
          </div>
          <div>
            <label className="text-xs text-gray-500">End</label>
            <input
              type="datetime-local"
              value={availabilityEnd}
              onChange={(event) => setAvailabilityEnd(event.target.value)}
              min={availabilityStart || undefined}
              className="mt-1 w-full text-sm border border-gray-200 rounded-lg px-3 py-2 focus:ring-teal-500 focus:border-teal-500"
            />
          </div>
          <div>
            <label className="text-xs text-gray-500">Note</label>
            <input
              type="text"
              value={availabilityNote}
              onChange={(event) => setAvailabilityNote(event.target.value)}
              placeholder="Reason (optional)"
              className="mt-1 w-full text-sm border border-gray-200 rounded-lg px-3 py-2 focus:ring-teal-500 focus:border-teal-500"
            />
          </div>
        </div>

        <label className="mt-3 flex items-center gap-2 text-xs text-gray-500">
          <input
            type="checkbox"
            checked={availabilityAllowConflicts}
            onChange={(event) => setAvailabilityAllowConflicts(event.target.checked)}
            className="rounded border-gray-300 text-teal-600 focus:ring-teal-500"
          />
          Allow conflicts with existing events
        </label>
      </div>

      <div className="bg-white rounded-xl border border-gray-200 shadow-sm flex flex-col h-[600px] relative">
        {loading && (
          <div className="absolute inset-0 bg-white/50 z-10 flex items-center justify-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-teal-600"></div>
          </div>
        )}

        {/* Header */}
        <div className="p-4 border-b border-gray-200 flex items-center justify-between">
          <h3 className="font-semibold text-slate-900">
            {format(currentDate, "MMMM yyyy")}
          </h3>
          <div className="hidden md:flex items-center gap-2 text-xs text-gray-500">
            <span className="px-2 py-0.5 rounded-full bg-indigo-50 text-indigo-700 border border-indigo-100">
              Event
            </span>
            <span className="px-2 py-0.5 rounded-full bg-emerald-50 text-emerald-700 border border-emerald-200">
              Available
            </span>
            <span className="px-2 py-0.5 rounded-full bg-teal-50 text-teal-700 border border-teal-200">
              Preferred
            </span>
            <span className="px-2 py-0.5 rounded-full bg-slate-100 text-slate-700 border border-slate-200">
              Busy
            </span>
            <span className="px-2 py-0.5 rounded-full bg-amber-50 text-amber-700 border border-amber-200">
              Out of office
            </span>
            <span className="px-2 py-0.5 rounded-full bg-rose-50 text-rose-700 border border-rose-200">
              Do not disturb
            </span>
          </div>
          <div className="flex items-center gap-2">
            <div className="hidden md:flex items-center gap-1 rounded-full border border-gray-200 p-1 text-xs">
              <button
                onClick={() => setViewMode("week")}
                className={`px-2 py-1 rounded-full ${
                  viewMode === "week"
                    ? "bg-slate-900 text-white"
                    : "text-gray-600 hover:bg-gray-100"
                }`}
              >
                Week
              </button>
              <button
                onClick={() => setViewMode("month")}
                className={`px-2 py-1 rounded-full ${
                  viewMode === "month"
                    ? "bg-slate-900 text-white"
                    : "text-gray-600 hover:bg-gray-100"
                }`}
              >
                Month
              </button>
            </div>
            <button
              onClick={() =>
                setCurrentDate(
                  viewMode === "month"
                    ? subMonths(currentDate, 1)
                    : addDays(currentDate, -7),
                )
              }
              className="p-1 hover:bg-gray-100 rounded"
            >
              <ChevronLeft className="w-5 h-5 text-gray-500" />
            </button>
            <button
              onClick={() => setCurrentDate(new Date())}
              className="text-sm font-medium text-teal-600 hover:bg-teal-50 px-3 py-1 rounded"
            >
              Today
            </button>
            <button
              onClick={() =>
                setCurrentDate(
                  viewMode === "month"
                    ? addMonths(currentDate, 1)
                    : addDays(currentDate, 7),
                )
              }
              className="p-1 hover:bg-gray-100 rounded"
            >
              <ChevronRight className="w-5 h-5 text-gray-500" />
            </button>
          </div>
        </div>

        {/* Grid */}
        <div className="flex-1 overflow-auto">
          {viewMode === "month" ? (
            <div className="min-w-[800px]">
              <div className="grid grid-cols-7 border-b border-gray-200 text-xs text-gray-500">
                {["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"].map((label) => (
                  <div
                    key={label}
                    className="p-3 text-center border-r border-gray-100 font-medium"
                  >
                    {label}
                  </div>
                ))}
              </div>
              <div className="grid grid-cols-7">
                {monthDays.map((day) => {
                  const indicators = getDayIndicators(day);
                  const isCurrentMonth = isSameMonth(day, currentDate);
                  return (
                    <button
                      key={day.toISOString()}
                      onClick={() => {
                        setCurrentDate(day);
                        setViewMode("week");
                      }}
                      className={`h-28 border-r border-b border-gray-100 p-2 text-left transition-colors ${
                        isCurrentMonth ? "bg-white" : "bg-gray-50 text-gray-400"
                      } hover:bg-teal-50`}
                    >
                      <div className="text-sm font-semibold">{format(day, "d")}</div>
                      <div className="mt-2 flex flex-wrap gap-1">
                        {indicators.includes("event") && (
                          <span className="h-2 w-2 rounded-full bg-indigo-400" />
                        )}
                        {indicators.includes(AvailabilityType.AVAILABLE) && (
                          <span className="h-2 w-2 rounded-full bg-emerald-400" />
                        )}
                        {indicators.includes(AvailabilityType.PREFERRED) && (
                          <span className="h-2 w-2 rounded-full bg-teal-400" />
                        )}
                        {indicators.includes(AvailabilityType.BUSY) && (
                          <span className="h-2 w-2 rounded-full bg-slate-400" />
                        )}
                        {indicators.includes(AvailabilityType.OUT_OF_OFFICE) && (
                          <span className="h-2 w-2 rounded-full bg-amber-400" />
                        )}
                        {indicators.includes(AvailabilityType.DO_NOT_DISTURB) && (
                          <span className="h-2 w-2 rounded-full bg-rose-400" />
                        )}
                      </div>
                    </button>
                  );
                })}
              </div>
            </div>
          ) : (
            <div className="min-w-[800px]">
            {/* Days Header */}
            <div className="grid grid-cols-8 border-b border-gray-200">
              <div className="p-3 text-xs font-medium text-gray-400 border-r border-gray-100">
                GMT+7
              </div>
              {weekDays.map((day) => (
                <div
                  key={day.toString()}
                  className={`p-3 text-center border-r border-gray-100 ${
                    isSameDay(day, new Date()) ? "bg-teal-50" : ""
                  }`}
                >
                  <p className="text-xs font-medium text-gray-500">
                    {format(day, "EEE")}
                  </p>
                  <p
                    className={`text-sm font-semibold ${
                      isSameDay(day, new Date())
                        ? "text-teal-600"
                        : "text-slate-900"
                    }`}
                  >
                    {format(day, "d")}
                  </p>
                </div>
              ))}
            </div>

            {/* Time Slots */}
            {hours.map((hour) => (
              <div
                key={hour}
                className="grid grid-cols-8 border-b border-gray-100"
              >
                {/* Time Label */}
                <div className="p-3 text-xs text-gray-500 text-right font-medium border-r border-gray-100">
                  {format(new Date().setHours(hour), "h a")}
                </div>

                {/* Day Cells */}
                {weekDays.map((day) => {
                  const slots = getSlotsForCell(day, hour);
                  return (
                    <div
                      key={`${day}-${hour}`}
                      className="border-r border-gray-100 p-1 min-h-[80px] hover:bg-gray-50 transition-colors relative"
                    >
                      {slots.map((slot) => (
                        <div
                          key={`${slot.id}-${hour}`}
                          className={`p-2 rounded text-xs mb-1 cursor-pointer ${getSlotStyles(
                            slot,
                          )}`}
                          title={`${slot.title} - ${formatSlotTime(slot)}`}
                        >
                          <div className="flex items-center justify-between gap-2">
                            <div className="font-semibold truncate">
                              {slot.title}
                            </div>
                            <span
                              className={`px-2 py-0.5 rounded-full text-[10px] font-semibold ${getSlotBadge(
                                slot,
                              ).className}`}
                            >
                              {getSlotBadge(slot).label}
                            </span>
                          </div>
                          <div className="flex items-center gap-1 mt-1 opacity-75">
                            <Clock className="w-3 h-3" />
                            <span>
                              {format(new Date(slot.startTime), "h:mm")} -{" "}
                              {format(new Date(slot.endTime), "h:mm a")}
                            </span>
                          </div>
                        </div>
                      ))}
                    </div>
                  );
                })}
              </div>
            ))}
          </div>
          )}
        </div>
      </div>
    </div>
  );
};
